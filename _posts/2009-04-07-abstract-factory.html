---
layout: post
title: Patterns abstract factory
author: bloggerming
tags:
- design_pattern
modified_time: '2015-12-03T02:07:55.689-08:00'
blogger_id: tag:blogger.com,1999:blog-3711184356900467447.post-8399572903637096040
blogger_orig_url: http://technoming.blogspot.com/2009/03/abstract-factory.html
---

<h3>use abstract factory if you need platform independence, for example if you  have an api that creates buttons and you need to modify the library so that you  can use it to create buttons wether you are on the windows platform or the mac  platform.</h3><br />from<br /><a href="http://www.vincehuston.org/dp/abstract_factory.html">http://www.vincehuston.org/dp/abstract_factory.html</a><br /><br /><h3>Intent</h3><ul><li>Provide an interface for creating families of related or dependent objects  without specifying their concrete classes. [GoF, p87]  </li><li>A hierarchy that encapsulates: many possible "platforms", and the  construction of a suite of "products".  </li><li>The <code>new</code> operator considered harmful. </li></ul><h3>Check list</h3><ol><li>Decide if "platform independence" and creation services are the current  source of pain.  </li><li>Map out a matrix of "platforms" versus "products".  </li><li>Define a factory interface that consists of a factory method per product.  </li><li>Define a factory derived class for each platform that encapsulates all  references to the <code>new</code> operator.  </li><li>The client should retire all references to <code>new</code>, and use the  factory methods to create the product objects. </li></ol>from<br /><a href="http://www.go4expert.com/forums/showthread.php?t=5127">http://www.go4expert.com/forums/showthread.php?t=5127</a><br /><br />We  have a requirement where we need to create control library and the same library  supports multiple platforms but the client code should not be changed if we  import from one operating system to the other.<br /><br />The solution is<br />The  client uses the GuiFactory to get the required factory of the supported  operating system and calls the same Show Method. Now depending on the platform  we change the factory but the client implementation remains the same. If support  for new operating system is to be added we need the new factory and the exact  implementation of the buttons and without changing the existing code we can  support the new platform.<br /><br />from wikipedia<br /><div><pre>/*<br />* GUIFactory example<br />*/<br />abstract class GUIFactory {<br />   public static GUIFactory getFactory() {<br />        int sys = readFromConfigFile("OS_TYPE");<br />       if (sys == 0) {<br />           return new WinFactory();<br />        } else {<br />           return new OSXFactory();<br />       }<br />   }<br /><br />   public abstract Button createButton();<br />}<br /><br /><br />class WinFactory extends GUIFactory {<br />   public Button createButton() {<br />       return new WinButton();<br />    }<br />}<br /><br /><br />class OSXFactory extends GUIFactory {<br />   public Button createButton() {<br />        return new OSXButton();<br />   }<br />}<br /><br /><br />abstract class Button {<br />   public abstract void paint();<br />}<br /><br /><br />class WinButton extends Button {<br />   public void paint() {<br />       System.out.println("I'm a WinButton: ");<br />    }<br />}<br /><br /><br />class OSXButton extends Button {<br />   public void paint() {<br />        System.out.println("I'm an OSXButton: ");<br />   }<br />}<br /><br /><br />public class Application {<br />    public static void main(String[] args) {<br />       GUIFactory factory = GUIFactory.getFactory();<br />        Button button = factory.createButton();<br />       button.paint();<br />   }<br />   // Output is either:<br />    //   "I'm a WinButton:"<br />   // or:<br />   //   "I'm an OSXButton:"<br />} </pre></div>